#!/usr/bin/env python3

import sys, socket, select, time, json, random, string, math
from constants import *
from decimal import *
from utils import timeout

# Your ID number
MY_ID = sys.argv[1]

# The ID numbers of all the other replicas
REPLICA_IDS = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(MY_ID)
#sys.stdout = open('log.txt', 'a+')
sys.stdout = open('log2.txt', 'a+')


last = 0

SELECT_WAIT_TIME = 0.01 # 10 milliseconds
TERMINATOR = b'}\n'
buffer = b''
CURRENT_TERM = 0
VOTED_FOR = None
LOG = dict(dict())
LEADER_ID = 'FFFF'
COMMIT_INDEX = 0
LAST_APPLIED = 0


def format_msg(src, dst, leader, msg_type, m_id, key=None, value=None, candidate_id=None, vote_granted=None, entries=None, leader_indx=None):
	global CURRENT_TERM
	if msg_type == GET:
		if key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		else:
			print(f'Invalid get. key missing')
	elif msg_type == PUT:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}
	
	elif msg_type == FAIL or msg_type == REDIRECT:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id}
	
	elif msg_type == OK:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}
		else:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id}
	elif msg_type == ELECT:
		# if vote_granted is None:
		# 	msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id}
		# else:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id, VOTE_GRANTED: vote_granted}
	elif msg_type == APPEND_LOG:
		msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, LAST_LOG_INDX: None, LAST_LOG_TERM: None, LOG_ENTRIES: entries, LEADER_INDX: leader_indx}
	
	return msg

# Receive 
def recv_msgs(sock, old_msgs):
	global buffer

	fresh_buf = sock.recv(16384)

	# is this sock shutting down?
	if len(fresh_buf) == 0:
			return None

	buffer += fresh_buf	

	msgs = []
	while TERMINATOR in buffer:
		position = buffer.find(TERMINATOR) + len(TERMINATOR)
		msgs.append(json.loads(buffer[:position - 1].decode()))  # -1 to remove the \n, which json.loads won't want
		buffer = buffer[position:]
	#put_msgs = [msg for msg in msgs if msg[TYPE] == PUT]
	#for each in put_msgs:
		#print("PUT PUT", each)
	# new_msgs = [new_msg for new_msg in msgs if new_msg not in msgs_dealt_with]
	new_msgs = old_msgs + msgs
	print("Old msgs: ", old_msgs)
	print("New messages: ", new_msgs)
	return new_msgs

def send_msg(sock, msg):
	print(f'SENDING: {msg}')
	sock.send(json.dumps(msg).encode() + b'\n')

def handle_get(sock, msg):
	global LEADER_ID, LOG
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		print(f'{MY_ID} RETRIEVING VALUE FOR KEY: {msg[KEY]}')
		# TODO: create class for this log
		val = LOG.get(CURRENT_TERM).get(COMMIT_INDEX)
		if val:
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID], value=val)
		else:
			print(f'VALUE NOT FOUND FOR KEY {msg[KEY]}')
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	elif msg[LEADER] == "FFFF":
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	else:
		raise Exception("We should never see this")
	send_msg(sock, response)

def send_append_entries(replica_OKs, start_time):
	# send append entries with data to all other replicas
	replica_ids_not_responded = [r_id for r_id in REPLICA_IDS if r_id not in replica_OKs]
	success_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in
				   range(len(replica_ids_not_responded))]
	append_entry_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id, entries=[LOG]) for replica_id, m_id
						 in
						 zip(replica_ids_not_responded, success_ids)]
	for msg in append_entry_msgs:
		send_msg(sock, msg)
	other_msgs = set()
	while True:
		new_msgs = recv_msgs(sock, list(other_msgs))
		other_msgs = []
		# then check if we have majority
		for msg in new_msgs:
			if msg[TYPE] == OK and msg[MID] in success_ids:
				replica_OKs.add(msg[SRC])
			else:
				other_msgs.add(msg)
		stop_time = time.time()
		append_entries_timeout = random.choice(TIMEOUT_RANGE) / 1000
		if round(Decimal(stop_time) - Decimal(start_time), 3) > append_entries_timeout:
			break
	return replica_OKs, other_msgs


def handle_put(sock, msg):
	global LEADER_ID, LOG, COMMIT_INDEX
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		replica_OKs = set()
		replica_OKs.add(MY_ID)
		while True:
			start_time = time.time()
			replica_OK_msgs, other_msgs = send_append_entries(replica_OKs, start_time)
			if len(replica_OK_msgs) > ((len(REPLICA_IDS) + 1) // 2):
				break
		# Note: if we never get a majority we will be stuck in this loop :)
		key = msg[KEY]
		val = msg[VALUE]
		print(f'{MY_ID} STORING KEY: {key} VALUE: {val}')
		key_val = (key, val)
		index_dict = dict()
		index_dict[COMMIT_INDEX] = key_val
		LOG[CURRENT_TERM].update(index_dict)
		COMMIT_INDEX += 1
		print(LOG[key])
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID])

	elif msg[LEADER] == "FFFF":
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	else:
		raise Exception("We should never see this")
	send_msg(sock, response)


def handle_log(sock, msg):
	global CURRENT_TERM, LOG
	success = True
	# reply false if term is less than current term
	msg_term = msg[TERM]
	if (msg_term < CURRENT_TERM):
		success = False
	#  Reply false if log doesnâ€™t contain an entry at prevLogIndex whose term matches prevLogTerm
	prev_log_index = len(LOG) - 1





	contact = True
	LEADER_ID = msg[LEADER]

	if msg_term > CURRENT_TERM:
		VOTED_FOR = None
	CURRENT_TERM = msg_term
	# might need to look at this
	LOG.update(msg[LOG_ENTRIES])



def handle_elect(sock, msg):
	global VOTED_FOR, LEADER_ID, CURRENT_TERM
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	#  New election called
	if msg[TERM] > CURRENT_TERM:
		LEADER_ID = 'FFFF'
		VOTED_FOR = None
		CURRENT_TERM = msg[TERM]
	vote_granted = VOTED_FOR == msg[C_ID]
	print(VOTED_FOR)
	if VOTED_FOR is None:
		vote_granted = True
		VOTED_FOR = msg[C_ID]
		# LEADER_ID = msg[C_ID]
		# CURRENT_TERM = msg[TERM]
	response = format_msg(msg[DST], msg[SRC], LEADER_ID, ELECT, msg[MID], candidate_id=msg[C_ID], vote_granted=vote_granted)
	send_msg(sock, response)
	return vote_granted	


def update_term(term=CURRENT_TERM):
	global CURRENT_TERM, VOTED_FOR
	if term > CURRENT_TERM:
		print(f'UPDATING TERM FROM {CURRENT_TERM} to {term}')
		CURRENT_TERM = term
	else:
		CURRENT_TERM+=1
		print(f'CURRENT TERM INCREMENTED TO {CURRENT_TERM}')
	VOTED_FOR = None

def begin_election(start, original_sock):
	global LEADER_ID, VOTED_FOR, CURRENT_TERM, LOG
	# Begin Election
	LEADER_ID = 'FFFF'
	update_term()
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	print(f'{MY_ID} STARTING LEADER ELECTION FOR TERM {CURRENT_TERM}') 
	VOTED_FOR = MY_ID
	votes = {MY_ID}
	msg_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
	vote_requests = [format_msg(MY_ID, replica_id, LEADER_ID, ELECT, m_id, candidate_id=MY_ID) for replica_id, m_id in zip(REPLICA_IDS, msg_ids)]
	for msg in vote_requests:
		send_msg(original_sock, msg)
	# A candidate continues in this state until one of three things happens: 
	all_servers = len(REPLICA_IDS) + 1
	msgs_to_keep = []
	while True:
		ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
		if sock in ready:
			election_msgs = recv_msgs(sock, msgs_to_keep)
			print("election_msgs", election_msgs)
			new_msgs_to_keep = [msg for msg in election_msgs if msg[TYPE] != ELECT and msg[TYPE] != APPEND_LOG]
			msgs_to_keep = msgs_to_keep + new_msgs_to_keep
			print("msgs_to_keep", msgs_to_keep)
			for msg in election_msgs:
				msg_term = msg.get(TERM)
				print(f'CANDIDATE {MY_ID} RECEIVED {msg}')
				if msg[TYPE] != ELECT and msg[TYPE] != APPEND_LOG:
					send_msg(sock, format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID]))
				if msg[TYPE] == ELECT and msg[VOTE_GRANTED] == True:
					votes.add(msg[SRC])
					print(f'Adding {msg[SRC]} to candidate votes {votes}')
				# (a) It wins the election
				if len(votes) > (all_servers // 2):
					print(f'ELECTION WON BY CANDIDATE {MY_ID} with votes {votes}')
					LEADER_ID = MY_ID
					print(f'LEADER_ID: {LEADER_ID} {MY_ID}')
					success_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
					success_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id, entries=LOG) for replica_id, m_id in zip(REPLICA_IDS, success_ids)]
					for msg in success_msgs:
						send_msg(sock, msg)
					return msgs_to_keep
				#  (b) Another server establishes itself as leader
				# If Leader's term is at least as large as the candidate's current term, the leader is recognized else ignore claim
				if (msg[TYPE] == APPEND_LOG) and (msg_term is not None and msg_term >= CURRENT_TERM):
					print(f'Acknowledging leadership claim by: {msg[SRC]} {msg}')
					LEADER_ID = msg[LEADER]
					# update_term(msg_term)
					CURRENT_TERM = msg_term
					# VOTED_FOR = None
					return msgs_to_keep
				# (c) a period of time goes by with no winner
				clock = time.time()
				total_time = round(Decimal(clock) - Decimal(start), 3)
				if total_time > election_timeout:
					print(f'ELECTION BY {MY_ID} ENDED WITH NO WINNER')
					return msgs_to_keep
			continue

# last = time.time()
old_msgs = []
while True:
	ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	
	if sock in ready:
		msgs = recv_msgs(sock, old_msgs)
		if len(old_msgs) > 0:
			old_msgs.clear()
			print("combined messages: ", msgs)
		contact = False
		for msg in msgs:
			if msg[TYPE] == GET and LEADER_ID != 'FFFF':
				handle_get(sock, msg)
			elif msg[TYPE] == PUT and LEADER_ID != 'FFFF':
				handle_put(sock, msg)
			elif msg[TYPE] == ELECT:
				if MY_ID == msg[C_ID]: continue
				contact = handle_elect(sock, msg)
			elif msg[TYPE] == APPEND_LOG:
				handle_log(sock, msg)
			# Handle noop messages. This may be removed from your final implementation
			elif msg['type'] == 'noop':
				print(f"{msg['dst']} received a NOOP from {msg['src']}")
			else:
				# Store old msgs for later if no leader
				old_msgs.append(msg)
		if contact:
			last = time.time() 
			continue
		if LEADER_ID == MY_ID:
			# Prevent other elections
			success_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
			success_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id, entries=[]) for replica_id, m_id in zip(REPLICA_IDS, success_ids)]
			for msg in success_msgs:
				send_msg(sock, msg)
		clock = time.time()
		total_time = round(Decimal(clock) - Decimal(last), 3)
		print(f'TIME TAKEN: {total_time}, ELECTION TIMEOUE: {election_timeout}')
		if total_time > election_timeout and LEADER_ID != MY_ID:
			non_election_msgs = begin_election(clock, sock)
			old_msgs = old_msgs + non_election_msgs
			print("messages from election: ", non_election_msgs)
			VOTED_FOR = None
		last = clock

print(LOG)
