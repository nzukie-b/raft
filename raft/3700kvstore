#!/usr/bin/env python3

import sys, socket, select, time, json, random, string, math
from constants import *
from decimal import *

# Your ID number
MY_ID = sys.argv[1]

# The ID numbers of all the other replicas
REPLICA_IDS = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(MY_ID)
#sys.stdout = open('log.txt', 'a+')
sys.stdout = open('log2.txt', 'a+')


last = 0

SELECT_WAIT_TIME = 0.01 # 10 milliseconds
TERMINATOR = b'}\n'
buffer = b''
CURRENT_TERM = 0
VOTED_FOR = None
LOG = dict()
LEADER_ID = 'FFFF'
COMMIT_INDEX = 0
LAST_APPLIED = 0


def format_msg(src, dst, leader, msg_type, m_id, key=None, value=None, candidate_id=None, vote_granted=None, entries=None, leader_indx=None):
	global CURRENT_TERM
	if msg_type == GET:
		if key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		else:
			print(f'Invalid get. key missing')
	elif msg_type == PUT:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}
	
	elif msg_type == FAIL or msg_type == REDIRECT:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id}
	
	elif msg_type == OK:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}
		else:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id}
	elif msg_type == ELECT:
		# if vote_granted is None:
		# 	msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id}
		# else:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id, VOTE_GRANTED: vote_granted}
	elif msg_type == APPEND_LOG:
		msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, LAST_LOG_INDX: None, LAST_LOG_TERM: None, LOG_ENTRIES: entries, LEADER_INDX: leader_indx}
	
	return msg

# Receive 
def recv_msgs(sock, msgs_dealt_with):
	global buffer

	fresh_buf = sock.recv(16384)

	# is this sock shutting down?
	if len(fresh_buf) == 0:
			return None

	buffer += fresh_buf	

	msgs = []
	while TERMINATOR in buffer:
		position = buffer.find(TERMINATOR) + len(TERMINATOR)
		msgs.append(json.loads(buffer[:position - 1].decode()))  # -1 to remove the \n, which json.loads won't want
		buffer = buffer[position:]
	#put_msgs = [msg for msg in msgs if msg[TYPE] == PUT]
	#for each in put_msgs:
		#print("PUT PUT", each)
	new_msgs = [new_msg for new_msg in msgs if new_msg not in msgs_dealt_with]
	print("Messages dealt with: ", msgs_dealt_with)
	print("New messages: ", new_msgs)
	return new_msgs

def send_msg(sock, msg):
	print(f'SENDING: {msg}')
	sock.send(json.dumps(msg).encode() + b'\n')

def handle_get(sock, msg):
	global LEADER_ID, LOG
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		print(f'{MY_ID} RETRIEVING VALUE FOR KEY: {msg[KEY]}')
		val = LOG.get(msg[KEY])
		if val:
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID], value=val)
		else:
			print(f'VALUE NOT FOUND FOR KEY {msg[KEY]}')
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	elif msg[LEADER] == "FFFF":
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	else:
		raise Exception("We should never see this")
	send_msg(sock, response)

def handle_put(sock, msg):
	global LEADER_ID, LOG
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		key = msg[KEY]
		val = msg[VALUE]
		print(f'{MY_ID} STORING KEY: {key} VALUE: {val}')
		LOG[key] = val
		print(LOG[key])
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID])
	elif msg[LEADER] == "FFFF":
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	else:
		raise Exception("We should never see this")
	send_msg(sock, response)

def handle_elect(sock, msg):
	global VOTED_FOR, LEADER_ID, CURRENT_TERM
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	#  New election called
	if msg[TERM] > CURRENT_TERM:
		LEADER_ID = 'FFFF'
		VOTED_FOR = None
		CURRENT_TERM = msg[TERM]
	vote_granted = VOTED_FOR == msg[C_ID]
	print(VOTED_FOR)
	if VOTED_FOR is None:
		vote_granted = True
		VOTED_FOR = msg[C_ID]
		# LEADER_ID = msg[C_ID]
		# CURRENT_TERM = msg[TERM]
	response = format_msg(msg[DST], msg[SRC], LEADER_ID, ELECT, msg[MID], candidate_id=msg[C_ID], vote_granted=vote_granted)
	send_msg(sock, response)
	return vote_granted	


def update_term(term=CURRENT_TERM):
	global CURRENT_TERM, VOTED_FOR
	if term > CURRENT_TERM:
		print(f'UPDATING TERM FROM {CURRENT_TERM} to {term}')
		CURRENT_TERM = term
	else:
		CURRENT_TERM+=1
		print(f'CURRENT TERM INCREMENTED TO {CURRENT_TERM}')
	VOTED_FOR = None

def begin_election(start, original_sock):
	global LEADER_ID, VOTED_FOR, CURRENT_TERM, LOG
	# TODO: Leader election is sending too many packets? > 20000
	# Begin Election
	LEADER_ID = 'FFFF'
	update_term()
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	print(f'{MY_ID} STARTING LEADER ELECTION FOR TERM {CURRENT_TERM}') 
	VOTED_FOR = MY_ID
	votes = {MY_ID}
	msg_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
	vote_requests = [format_msg(MY_ID, replica_id, LEADER_ID, ELECT, m_id, candidate_id=MY_ID) for replica_id, m_id in zip(REPLICA_IDS, msg_ids)]
	for msg in vote_requests:
		send_msg(original_sock, msg)
	# A candidate continues in this state until one of three things happens: 
	all_servers = len(REPLICA_IDS) + 1
	msgs_dealt_with = []
	msgs_to_keep = []
	while True:
		ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
		if sock in ready:
			election_msgs = recv_msgs(sock, msgs_dealt_with)
			print("election_msgs", election_msgs)
			new_msgs_to_keep = [msg for msg in election_msgs if msg[TYPE] != ELECT and msg[TYPE] != APPEND_LOG]
			msgs_to_keep = msgs_to_keep + new_msgs_to_keep
			print("msgs_to_keep", msgs_to_keep)
			for msg in election_msgs:
				msg_term = msg.get(TERM)
				print(f'CANDIDATE {MY_ID} RECEIVED {msg}')
				if msg[TYPE] != ELECT and msg[TYPE] != APPEND_LOG:
					send_msg(sock, format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID]))
				if msg[TYPE] == ELECT and msg[VOTE_GRANTED] == True:
					votes.add(msg[SRC])
					print(f'Adding {msg[SRC]} to candidate votes {votes}')
				# (a) It wins the election
				if len(votes) > (all_servers // 2):
					print(f'ELECTION WON BY CANDIDATE {MY_ID} with votes {votes}')
					LEADER_ID = MY_ID
					print(f'LEADER_ID: {LEADER_ID} {MY_ID}')
					success_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
					success_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id, entries=LOG) for replica_id, m_id in zip(REPLICA_IDS, success_ids)]
					for msg in success_msgs:
						send_msg(sock, msg)
					return []
				#  (b) Another server establishes itself as leader
				# If Leader's term is at least as large as the candidate's current term, the leader is recognized else ignore claim
				if (msg[TYPE] == APPEND_LOG) and (msg_term is not None and msg_term >= CURRENT_TERM):
					print(f'Acknowledging leadership claim by: {msg[SRC]} {msg}')
					LEADER_ID = msg[LEADER]
					# update_term(msg_term)
					CURRENT_TERM = msg_term
					# VOTED_FOR = None
					return []
				# (c) a period of time goes by with no winner
				clock = time.time()
				total_time = round(Decimal(clock) - Decimal(start), 3)
				if total_time > election_timeout:
					print(f'ELECTION BY {MY_ID} ENDED WITH NO WINNER')
					return []
	return []

# last = time.time()
msgs_received_during_election = []
while True:
	ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	
	if sock in ready:
		msgs_dealt_with = []
		msgs = recv_msgs(sock, msgs_dealt_with)
		if len(msgs_received_during_election) > 0:
			msgs = msgs_received_during_election + msgs
			print("combined messages: ", msgs)
		contact = False
		for msg in msgs:
			if msg[TYPE] == GET:
				handle_get(sock, msg)
			elif msg[TYPE] == PUT:
				handle_put(sock, msg)
			elif msg[TYPE] == ELECT:
				if MY_ID == msg[C_ID]: continue
				contact = handle_elect(sock, msg)
			elif msg[TYPE] == APPEND_LOG:
				contact = True
				LEADER_ID = msg[LEADER]
				CURRENT_TERM = msg[TERM]
				#print(f'{MY_ID} updating {LOG} with {msg[LOG_ENTRIES]}')
				LOG.update(msg[LOG_ENTRIES])
			# Handle noop messages. This may be removed from your final implementation
			elif msg['type'] == 'noop':
				print(f"{msg['dst']} received a NOOP from {msg['src']}")
			# keep track of messages we have already dealt with
			msgs_dealt_with.append(msg)
		if contact:
			last = time.time() 
			continue
		if LEADER_ID == MY_ID:
			# Prevent other elections
			success_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
			success_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id, entries=LOG) for replica_id, m_id in zip(REPLICA_IDS, success_ids)]
			for msg in success_msgs:
				send_msg(sock, msg)
		# TODO: Leader election seems to send > 20,000 number of packets?
		clock = time.time()
		total_time = round(Decimal(clock) - Decimal(last), 3)
		print(total_time, election_timeout)
		if total_time > election_timeout and LEADER_ID != MY_ID:
			msgs_received_during_election = begin_election(clock, sock)
			print("messages from election: ", msgs_received_during_election)
			VOTED_FOR = None
			last = clock
		# last = clock

print(LOG)
