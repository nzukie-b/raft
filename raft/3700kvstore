#!/usr/bin/env python3

import sys, socket, select, time, json, random, string, math
from constants import *
from decimal import *

# Your ID number
MY_ID = sys.argv[1]

# The ID numbers of all the other replicas
REPLICA_IDS = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(MY_ID)
# sys.stdout = open('log.txt', 'w')


last = 0

SELECT_WAIT_TIME = 0.01 # 10 milliseconds
TERMINATOR = b'}\n'
buffer = b''
CURRENT_TERM = 0
VOTED_FOR = None
LOG = dict()
LEADER_ID = 'FFFF'
COMMIT_INDEX = 0
LAST_APPLIED = 0


def format_msg(src, dst, leader, msg_type, m_id, key=None, value=None, candidate_id=None, vote_granted=None, entries=None, leader_indx=None):
	global CURRENT_TERM
	if msg_type == GET:
		if key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		else:
			print(f'Invalid get. key missing')
	elif msg_type == PUT:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif key:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}
	
	elif msg_type == FAIL or msg_type == REDIRECT:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id}
	
	elif msg_type == OK:
		if key and value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, KEY: key, VALUE: value}
		elif value:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, VALUE: value}

	elif msg_type == ELECT:
		# if vote_granted is None:
		# 	msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id}
		# else:
			msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, C_ID: candidate_id, VOTE_GRANTED: vote_granted}
	elif msg_type == APPEND_LOG:
		msg = {SRC: src, DST: dst, LEADER: leader, TYPE: msg_type, MID:m_id, TERM: CURRENT_TERM, LAST_LOG_INDX: None, LAST_LOG_TERM: None, LOG_ENTRIES: entries, LEADER_INDX: leader_indx}
	
	return msg

# Receive 
def recv_msgs(sock):
	global buffer

	fresh_buf = sock.recv(16384)

	# is this sock shutting down?
	if len(fresh_buf) == 0:
			return None

	buffer += fresh_buf	

	msgs = []
	while TERMINATOR in buffer:
		position = buffer.find(TERMINATOR) + len(TERMINATOR)
		msgs.append(json.loads(buffer[:position - 1].decode()))  # -1 to remove the \n, which json.loads won't want
		buffer = buffer[position:]
	return msgs

def send_msg(sock, msg):
	print(f'SENDING: {msg}')
	sock.send(json.dumps(msg).encode() + b'\n')

def handle_get(sock, msg):
	global LEADER_ID, LOG
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		val = LOG.get(msg[KEY])
		if val:
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID], value=val)
		else:
			response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	else:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	send_msg(sock, response)

def handle_put(sock, msg):
	global LEADER_ID, LOG
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	if msg[LEADER] != MY_ID:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, REDIRECT, msg[MID])
	elif msg[LEADER] == MY_ID:
		key = msg[KEY]
		val = msg[VALUE]
		LOG[key] = val
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, OK, msg[MID])
	else:
		response = format_msg(msg[DST], msg[SRC], LEADER_ID, FAIL, msg[MID])
	send_msg(sock, response)

def handle_elect(sock, msg):
	global VOTED_FOR, LEADER_ID, CURRENT_TERM
	print(f"{msg[DST]} received a {msg[TYPE]} from {msg[SRC]}: {msg}")
	vote_granted = VOTED_FOR == msg[C_ID]
	print(VOTED_FOR)
	if (VOTED_FOR is None or VOTED_FOR == msg[C_ID]) and msg[TERM] > CURRENT_TERM:
		vote_granted = True
		VOTED_FOR = msg[C_ID]
		# LEADER_ID = msg[C_ID]
		CURRENT_TERM = msg[TERM]
	response = format_msg(msg[DST], msg[SRC], LEADER_ID, ELECT, msg[MID], candidate_id=msg[C_ID], vote_granted=vote_granted)
	send_msg(sock, response)
	return vote_granted	


def update_term():
	global CURRENT_TERM, VOTED_FOR
	CURRENT_TERM+=1
	VOTED_FOR = None

def begin_election(clock):
	global LEADER_ID, VOTED_FOR, CURRENT_TERM
	"""Return the ID of the winner"""
	# Begin Election
	LEADER_ID = 'FFFF'
	update_term()
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	print(f'{MY_ID} STARTING LEADER ELECTION FOR TERM {CURRENT_TERM}') 
	VOTED_FOR = MY_ID
	votes = {MY_ID}
	msg_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
	vote_requests = [format_msg(MY_ID, replica_id, LEADER_ID, ELECT, m_id, candidate_id=MY_ID) for replica_id, m_id in zip(REPLICA_IDS, msg_ids)]
	for msg in vote_requests:
		send_msg(sock, msg)
	last = clock
	# A candidate continues in this state until one of three things happens: 
	all_servers = len(REPLICA_IDS) + 1
	while True:
		ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
		if sock in ready:
			election_msgs = recv_msgs(sock)
			for msg in election_msgs:
				msg_term = msg.get(TERM)
				print(f'CANDIDATE {MY_ID} RECEIVED {msg}')
				if msg[TYPE] == ELECT and msg[VOTE_GRANTED] == True:
					votes.add(msg[SRC])
					print(f'Adding {msg[SRC]} to candidate votes {votes}')
				# (a) It wins the election
				if len(votes) >= (all_servers // 2) + 1:
					print(f'ELECTION WON BY {MY_ID} with votes {votes}')
					LEADER_ID = MY_ID
					msg_ids = [''.join(random.choices(string.ascii_letters + string.digits, k=12)) for ii in range(len(REPLICA_IDS))]
					success_msgs = [format_msg(MY_ID, replica_id, LEADER_ID, APPEND_LOG, m_id) for replica_id, m_id in zip(REPLICA_IDS, msg_ids)]
					for msg in vote_requests:
						send_msg(sock, msg)
					return
				#  (b) Another server establishes itself as leader
				# If Leader's term is at least as large as the candidate's current term, the leader is recognized else ignore claim
				if (msg[TYPE] == APPEND_LOG or msg[LEADER] != 'FFFF') and (msg_term is not None and msg_term >= CURRENT_TERM):
					print(f'leadership claim: {msg}')
					LEAD_ID = msg[LEADER]
					CURRENT_TERM = msg[TERM]
					VOTED_FOR = None
					return
				# (c) a period of time goes by with no winner
				clock = time.time()
				total_time = round(Decimal(clock) - Decimal(last), 3)
				if total_time >= election_timeout:
					return
			continue

# last = time.time()
while True:
	ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
	election_timeout = random.choice(TIMEOUT_RANGE) / 1000
	
	if sock in ready:
		msgs = recv_msgs(sock)
		contact = False
		for msg in msgs:
			if msg[TYPE] == GET:
				handle_get(sock, msg)
			elif msg[TYPE] == PUT:
				handle_put(sock, msg)
			elif msg[TYPE] == ELECT:
				contact = handle_elect(sock, msg)
			elif msg[TYPE] == APPEND_LOG:
				contact = True
				LEADER_ID = msg[LEADER]
				TERM = msg[CURRENT_TERM]

				# last = time.time()
			# Handle noop messages. This may be removed from your final implementation
			elif msg['type'] == 'noop':
				print(f"{msg['dst']} received a NOOP from {msg['src']}")
		if contact:
			last = time.time() 
			continue

	# TODO: Where to update time to avoid a having replicas timeout during election???
	clock = time.time()
	total_time = round(Decimal(clock) - Decimal(last), 3)
	print(total_time, election_timeout)
	if total_time >= election_timeout:
		begin_election(clock)
		last = time.time()
		# last = clock
